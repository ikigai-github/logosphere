import _ = require('lodash');
import randomstring = require('randomstring');
import { sha3_256 } from 'js-sha3';
import path from 'path';
import { String } from 'typescript-string-operations';
import sleep = require('sleep-promise');
import { jsonFederatedSchemaLoader, JsonFederatedSchema } from '../json-schema';
import { Configuration, ModuleConfiguration, loadConfiguration } from '../../configuration';
import * as FlureeConstants from '../../common/const';
import {
  FlureeService,
  FlureePredicate,
  FlureeQuery,
  Predicates,
  FlureeCollection,
  predicates,
  deprecatePredicate
} from '../../services/fluree';
import { FileUtil } from '../../common/file-util';
import { isArray } from '../../common/util';


import {
  TYPE,
  OBJECT,
  COMMENT,
  STRING,
  IDENTIFIER,
  NUMBER,
  INTEGER,
  DESCRIPTION,
  EXAMPLES,
  ENUM,
  DEFS,
  REF,
  PROPERTIES,
  ARRAY,
  ITEMS,
  UNDERSCORE,
  BIGINT,
  INSTANT,
  TIME,
  TYPE_JSON,
  COLLECTION_REF,
  BASE_STRING,
  UNIX_TIME,
  MAX_LENGTH,
  ALPHABETIC,
  BOOLEAN,
  MAX_ITEMS,
  MIN_ITEMS,
} from '../../common/const';

/**
 * Generic class to generate schema for any input JSON schema file
 *
 * @author : Manik-Jain
 */
//DO NOT EDIT THIS FILE
export default class FlureeSchema {
  public readonly modelSchema: any;
  public readonly dao: FlureeService;
  public readonly fileUtil: FileUtil;

  private config: ModuleConfiguration;
  private toProcessCollections: string[];
  private collections: string[];
  private processedCollections: string[];
  private identifiers: any[] = [];
  public toInsertData: any = {};
  private pendingTransactions: any = {};
  private collectionObject = {};
  private collectionDefinitions: any[] = [];
  private modifiers: any[] = [];

  constructor(module: string) {
    this.config = loadConfiguration().modules.find(
        (m: ModuleConfiguration) => m.name === module
      )

    this.modelSchema = jsonFederatedSchemaLoader().find(
      (m: JsonFederatedSchema) => m.module === module
    ).schema;
    this.dao = new FlureeService();
    this.fileUtil = new FileUtil();
    this.toProcessCollections = [];
    this.collections = [];
    this.processedCollections = [];
    this.modifiers = [];
  }

  /**
   * recursively groups the indepedent and dependent collections
   *
   * @returns
   */
  sequence() {
    const referencedCollections: any[] = [];
    const independentCollections: any[] = [];

    Object.keys(this.modelSchema)
      .forEach((collection) => {
        const map = new Map();
        const predicateMap = new Map();

        Object.keys(this.modelSchema[collection][PROPERTIES]).forEach(
          (predicate) => {
            const predicateValue =
              this.modelSchema[collection][PROPERTIES][predicate];

            if (predicateValue[REF]) {
              const referenced = predicateValue[REF].replace(
                DEFS,
                String.Empty
              );
              
                predicateMap.set(predicate, referenced);

            } else if (
              predicateValue[TYPE] === ARRAY &&
              REF in predicateValue[ITEMS]
            ) {
              const referenced = predicateValue[ITEMS][REF].replace(
                DEFS,
                String.Empty
              ); 
                predicateMap.set(predicate, referenced);
            }
          }
        );

        if (predicateMap.size === 0) {
          independentCollections.push(collection);
        } else {
          map.set(collection, predicateMap);
          referencedCollections.push(map);
        }
      });

    const map = new Map();

    referencedCollections.reduce((acc, val, index) => {
      map.set(index, val.get(val.keys().next().value).size);
      acc.push(val.get(val.keys().next().value).size);
      return acc;
    }, []);

    const sortedReferenced: any[] = [];
    Array.from(map.values())
      .sort((a, b) => a - b)
      .forEach((entry) => {
        const key = this.getKey(map, entry)[0];
        sortedReferenced.push(referencedCollections[key]);
        map.delete(key);
      });

    this.toProcessCollections = independentCollections;
    const keyValue = {};

    sortedReferenced.forEach((entry) => {
      for (const [key, value] of entry.entries()) {
        const children: string[] = [];
        for (const [childKey, childValue] of value.entries()) {
          children.push(childValue);
        }
        keyValue[key] = children;
      }
    });

    const associative: string[] = [];

    Object.keys(keyValue).forEach((key) => {
      const dependencies: string[] = keyValue[key];
      dependencies.forEach((dependency) => {
        if (!Object.keys(keyValue).includes(dependency)) {
          this.toProcessCollections.push(dependency);
          if (dependencies.length === 1) {
            this.toProcessCollections.push(key);
          }
        } else {
          associative.push(dependency);
          associative.push(key);
        }
      });
    });

    const sequence = {
      independentCollections: Array.from(new Set(this.toProcessCollections)),
      sortedReferenced: Array.from(new Set(associative)),
    };

    //this.fileUtil.write(path.resolve(__dirname + '/sequence.json'), sequence)

    return sequence;
  }

  getKey(map, searchValue) {
    return [...map.entries()]
      .filter(({ 1: v }) => v === searchValue)
      .map(([k]) => k);
  }

  /**
   * Connects to the fluree instance in order to check the existing collections, if any
   * @returns
   */
  async getCollections(): Promise<string[]> {
    const query: FlureeQuery = {
      select: [Predicates.NAME],
      from: FlureeCollection.COLLECTION,
    };

    const response = await this.dao.query(
        this.config.fluree.ledgerUrl, 
        `${this.config.fluree.network}/${this.config.fluree.db}`, 
        query
    );

    return response.reduce((acc, entry) => {
      if (!entry.name.startsWith(UNDERSCORE)) {
        acc.push(entry.name);
      }
      return acc;
    }, []);
  }

  async getPredicates(collection: string): Promise<string[]> {
    const response = await this.dao.query(
        this.config.fluree.ledgerUrl, 
        `${this.config.fluree.network}/${this.config.fluree.db}`,
        predicates(collection)
    );
    return response.reduce((acc, entry) => {
      acc.push(entry.substring(entry.indexOf('/') + 1, entry.length));
      return acc;
    }, []);
  }

  async init(dump: boolean) {
    try {
      // create database if it doesn't exist
      const dbs: string[] = await this.dao.listDBs(this.config.fluree.ledgerUrl);
      if (
        !dbs.find(
          (db: string) =>
            db === `${this.config.fluree.network}/${this.config.fluree.db}`
        )
      ) {
        await this.dao.createDB(this.config.fluree.ledgerUrl,  `${this.config.fluree.network}/${this.config.fluree.db}`);
        // pausing for 10 sec to let DB initialize
        // there doesn't seem to be a clean way for pinging the status
        // but if we find one later on, we may want to change that
        await sleep(10000);
      } else {
        console.log(
          `Database ${this.config.fluree.db} already exists`
        );
      }

      this.collections = await this.getCollections();

      const entities = Object.keys(this.modelSchema)

      for await (const entity of entities) {
        //Handle changes when new collections are added to schema
        if (!this.collections.includes(entity)) {
          console.log(`Preparing collection : ${entity.toUpperCase()}`);
          this.collectionObject[entity.toLocaleUpperCase()] = entity;
          const collection = this.generateCollection(entity);
          this.collectionDefinitions.push(collection);
          this.collectionDefinitions = _.flattenDeep(
            this.collectionDefinitions
          );
        }

        //handle case of any new predicate addition/removals
        else {
          console.log(
            `Checking any schema changes with collection : ${entity.toUpperCase()}`
          );
          const dbPredicates: string[] = await this.getPredicates(entity);
          const modifiers = this.resolve(entity, dbPredicates);

          if (isArray(modifiers)) {
            console.log(
              `Found schema changes for collection : ${entity.toUpperCase()}`
            );
            this.modifiers.push(modifiers);
            this.modifiers = _.flattenDeep(this.modifiers);
            console.log(`Updated modifier : ${this.modifiers.toString()}`);
          } else {
            console.log(
              `Found NO schema changes for collection : ${entity.toUpperCase()}. Proceeding with any further collection`
            );
          }
        }
      }

      if (this.collectionDefinitions.length > 0 && dump) {
        // this.fileUtil.write(
        //   path.resolve(__dirname + '/collections.json'),
        //   this.collectionDefinitions
        // );
        await this.dao.transact(
            this.config.fluree.ledgerUrl,
            `${this.config.fluree.network}/${this.config.fluree.db}`,
            this.collectionDefinitions
        );
      }

      if (this.modifiers.length > 0 && dump) {
        // this.fileUtil.write(
        //   path.resolve(__dirname + '/collection_modifiers.json'),
        //   this.modifiers
        // );
        await this.dao.transact(
            this.config.fluree.ledgerUrl,
            `${this.config.fluree.network}/${this.config.fluree.db}`,
            this.modifiers
        );
      }

      console.log('DB synchronised with schema...');
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  async initialize(dump: boolean) {
    const collections = this.sequence();
    collections.independentCollections.forEach(async (collection) => {
      this.process(collection, false);
    });
    collections.sortedReferenced.forEach(async (entity) =>
      this.process(entity, false)
    );

    if (Object.keys(this.pendingTransactions).length > 0) {
      Object.keys(this.pendingTransactions).forEach((key) => {
        const pendingArray = this.pendingTransactions[key];
        this.toInsertData[key].forEach((entry) => {
          pendingArray.forEach((pendingKey) => {
            Object.keys(pendingKey).forEach((pKey) => {
              entry[pKey] =
                this.toInsertData[pendingKey[pKey]][0][Predicates._ID];
            });
          });
        });
      });
    }

    let data: any[] = [];
    Object.keys(this.toInsertData).forEach(async (key) => {
      data.push(this.toInsertData[key]);
      data = _.flatten(data);
    });

    if (dump) {
      //(path.resolve(__dirname + '/data.json'), data);
      await this.dao.transact(
            this.config.fluree.ledgerUrl,
            `${this.config.fluree.network}/${this.config.fluree.db}`,
            data
        );
    }

    console.log('Insertion complete...');
  }

  private process(collection: string, dump?: boolean) {
    if (this.processedCollections.includes(collection)) {
      console.log(
        `${collection} was already processed, and hence skipping re-init`
      );
      return;
    }

    console.log(`Processing ${collection}`);
    const transactions: any[] = [];
    const transaction = this.parse(collection);
    console.log(`Transaction: ${JSON.stringify(transaction)}`)
    if (transaction) {
      transactions.push(transaction);
      this.toInsertData[collection] = transactions;
      this.processedCollections.push(collection);
      this.identifiers[collection] =
        this.identifiers[collection] !== undefined &&
        this.identifiers[collection].size !== 0
          ? this.identifiers[collection].push(transaction[IDENTIFIER])
          : [transaction[IDENTIFIER]];
      console.log(`Finished Processing ${collection}`);
    }
  }

  public extractValue(type: string, entity: any) {
    if (type === STRING) {
      if (entity[EXAMPLES] !== undefined) {
        const value =
          entity[EXAMPLES][
            Math.floor(Math.random() * (entity[EXAMPLES].length - 1 + 1) + 1)
          ];
        return value !== undefined ? value : entity[EXAMPLES][0];
      } else if (entity[ENUM] !== undefined && Array.isArray(entity[ENUM])) {
        const value =
          entity[ENUM][Math.floor(Math.random() * entity[ENUM].length)];
        return value !== undefined ? value : BASE_STRING;
      } else {
        return randomstring.generate({
          length: entity[MAX_LENGTH],
          charset: ALPHABETIC,
        });
      }
    } else if (type === NUMBER || type === INTEGER) {
      if (
        entity[DESCRIPTION] !== undefined &&
        entity[DESCRIPTION].includes(UNIX_TIME)
      ) {
        return (
          Date.now() +
          FlureeConstants.ONE_DAY_MS * Math.floor(Math.random() * 100)
        );
      } else {
        return Math.floor(
          Math.random() * (FlureeConstants.ONE_THOUSAND - 1 + 1) + 1
        );
      }
    }
  }

  public parse(entity: string) {
    let isPending = false;
    const schema = this.modelSchema[entity];
    const keys = Object.keys(schema.properties);
    const data = {};
    const pending: any[] = [];
    for (let key = 0; key < keys.length; key++) {
      const type = schema.properties[keys[key]][TYPE];
      if (type === STRING) {
        data[keys[key]] = this.extractValue(type, schema.properties[keys[key]]);
      } else if (type === ARRAY && REF in schema.properties[keys[key]][ITEMS]) {
        const referenced = schema.properties[keys[key]];
        const childEntity = schema.properties[keys[key]][ITEMS][REF].replace(
          DEFS,
          String.Empty
        );
        const index: number = referenced[MAX_ITEMS]
          ? referenced[MAX_ITEMS]
          : referenced[MIN_ITEMS]
          ? referenced[MIN_ITEMS]
          : 0;
        if (Object.keys(this.toInsertData).includes(childEntity)) {
          data[keys[key]] = [this.toInsertData[childEntity][0][Predicates._ID]];
        }
        if (index > 0) {
          const identifiers: any[] = [];
          for (let i = 0; i < index; i++) {
            const appendedChild = this.parse(childEntity);
            identifiers.push(appendedChild[Predicates._ID]);
            this.toInsertData[childEntity].push(appendedChild);
          }
          data[keys[key]] = identifiers;
        }
      }
      //scalar array
      else if (
        type === ARRAY &&
        ITEMS in schema.properties[keys[key]] &&
        schema.properties[keys[key]][ITEMS][TYPE] === STRING
      ) {
        data[keys[key]] = [
          randomstring.generate({
            length: entity[MAX_LENGTH],
            charset: ALPHABETIC,
          }),
        ];
      } else if (type === NUMBER || type === INTEGER) {
        data[keys[key]] = this.extractValue(type, schema.properties[keys[key]]);
      } else if (type === BOOLEAN) {
        data[keys[key]] = false;
      } else if (schema.properties[keys[key]][REF]) {
        const ref = schema.properties[keys[key]][REF].replace(
          DEFS,
          String.Empty
        );
        if (
          this.modelSchema[ref][TYPE] === OBJECT &&
          !Object.keys(this.toInsertData).includes(ref)
        ) {
          isPending = true;
          Array.isArray(pending)
            ? pending.push({ [keys[key]]: ref })
            : [{ [keys[key]]: ref }];
        } else if (
          this.modelSchema[ref][TYPE] === OBJECT &&
          Object.keys(this.toInsertData).includes(ref)
        ) {
          data[keys[key]] = this.toInsertData[ref][0][Predicates._ID];
        } else if (
          this.modelSchema[ref][TYPE] === STRING &&
          this.modelSchema[ref][ENUM] !== undefined
        ) {
          data[keys[key]] = this.modelSchema[ref][ENUM][0];
        }
      }
    }
    data[Predicates._ID] = entity;
   
    data[IDENTIFIER] = sha3_256(JSON.stringify(data));
    data[Predicates._ID] = `${entity}$${data[IDENTIFIER]}`;
    
    if (keys.includes(FlureeConstants.CREATED_AT)) {
      data[FlureeConstants.CREATED_AT] = Date.now();
    }

    if (isPending) {
      this.pendingTransactions[entity] = pending;
    }

    return data;
  }

  /**
   * Generate collection transaction string
   *
   * @returns Collection transact statement
   */
  generateCollection(entityName): any[] {
    console.log(
      '*'.repeat(25) + '\n' + entityName.toUpperCase() + '\n' + '*'.repeat(25)
    );

    const collection: any[] = [
      {
        _id: Predicates.COLLECTION,
        name: entityName,
      },
    //   {
    //     _id: Predicates.PREDICATE,
    //     name: `${entityName}`.concat('/').concat(Predicates.OWNER),
    //     doc: `The ${entityName}'s data owner`,
    //     type: COLLECTION_REF,
    //     restrictCollection: FlureeCollection.USER,
    //     index: true,
    //   },
      {
        _id: Predicates.PREDICATE,
        name: `${entityName}`.concat('/').concat(Predicates.IDENTIFIER),
        doc: `The ${entityName}'s identifier`,
        type: STRING,
        unique: true,
        index: true,
      },
    ];
    const entitySchema = this.modelSchema[entityName];
    const collectionPredicates = Object.keys(entitySchema.properties).reduce(
      (acc, k: string) => {
        acc.push(this.preparePredicate(entityName, k, entitySchema));
        return acc;
      },
      collection
    );
    return collectionPredicates;
  }

  resolve(entityName: string, dbPredicates: string[]): any[] {
    const entitySchema = this.modelSchema[entityName];
    const collectionPredicates = Object.keys(entitySchema.properties);
    const transaction: any[] = [];

    const toAddPRedicates = _.difference(collectionPredicates, dbPredicates);

    toAddPRedicates.forEach((predicate) => {
      transaction.push(
        this.preparePredicate(entityName, predicate, entitySchema)
      );
    });

    const toDeletePRedicates = _.difference(dbPredicates, collectionPredicates);
    toDeletePRedicates.forEach((predicate) => {
      if (predicate !== 'owner') {
        transaction.push(deprecatePredicate(entityName, predicate));
      }
    });

    return transaction;
  }

  preparePredicate(
    entityName: string,
    predicateName: string,
    entitySchema: any
  ) {
    const predicate: FlureePredicate = {
      _id: Predicates.PREDICATE,
      name: `${entityName}/${predicateName}`,
      doc: `${entityName}'s ${predicateName} field`,
      ...(predicateName === IDENTIFIER && {
        index: true,
        unique: true,
      }),
      type: STRING,
    };

    let type = entitySchema.properties[predicateName][TYPE];
    if (
      type === ARRAY && //object array
      ITEMS in entitySchema.properties[predicateName] &&
      REF in entitySchema.properties[predicateName][ITEMS]
    ) {
      predicate.type = COLLECTION_REF;
      predicate.restrictCollection = entitySchema.properties[predicateName][
        ITEMS
      ][REF].replace(DEFS, String.Empty);
      predicate.multi = true;
    } else if (
      type === ARRAY && // scalar array
      ITEMS in entitySchema.properties[predicateName] &&
      TYPE in entitySchema.properties[predicateName][ITEMS]
    ) {
      predicate.type = entitySchema.properties[predicateName][ITEMS][TYPE];
      predicate.multi = true;
    } else if (type === OBJECT) {
      predicate.type = TYPE_JSON;
    } else if (
      entitySchema.properties[predicateName][DESCRIPTION] !== undefined &&
      entitySchema.properties[predicateName][DESCRIPTION].toString().includes(
        TIME
      )
    ) {
      predicate.type = INSTANT;
    } else {
      type = type === INTEGER || type === NUMBER ? BIGINT : type;
      predicate.type = entitySchema.properties[predicateName][REF]
        ? COLLECTION_REF
        : type;
    }

    const comments =
      entitySchema.properties[predicateName][COMMENT] !== undefined
        ? entitySchema.properties[predicateName][COMMENT]
        : undefined;

    if (comments) {
      JSON.parse(comments)?.unique === true
        ? (predicate.unique = true)
        : (predicate.unique = false);
      JSON.parse(comments)?.fullTextSearch === true
        ? (predicate.fullText = true)
        : (predicate.fullText = false);
    }

    // referenced collections
    if (entitySchema.properties[predicateName][REF]) {
      const restrictCollection =
        this.modelSchema[
          entitySchema.properties[predicateName][REF].replace(
            DEFS,
            String.Empty
          )
        ];

      if (restrictCollection[TYPE] === OBJECT) {
        predicate.restrictCollection = entitySchema.properties[predicateName][
          REF
        ].replace(DEFS, String.Empty);
      } else {
        predicate.type = STRING;
      }
    }
    predicate.index = true;

    return predicate;
  }
}
