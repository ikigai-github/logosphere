import _ = require('lodash');
import randomstring = require('randomstring');
import { sha3_256 } from 'js-sha3';
import sleep = require('sleep-promise');
import { workspaceRoot } from '@nrwl/devkit';
import {
  CanonicalSchema,
  canonicalSchemaLoader,
  Definition,
  DefinitionType,
  Property,
} from '@logosphere/converters';
import { ModuleConfiguration } from '@logosphere/configuration';
import {
  FlureeService,
  FlureePredicate,
  FlureeQuery,
  Predicates,
  FlureeCollection,
  predicates,
  deprecatePredicate,
  CREATED_AT,
} from '@logosphere/fluree';
import { FileUtil, isArray } from '@logosphere/utils';

import {
  ALPHABETIC,
  BIGINT,
  BOOLEAN,
  COLLECTION_REF,
  IDENTIFIER,
  INTEGER,
  INSTANT,
  NUMBER,
  ONE_DAY_MS,
  ONE_THOUSAND,
  STRING,
  TIME,
  UNDERSCORE,
  UNIX_TIME,
} from './const';

/**
 * Generic class to generate schema for any input JSON schema file
 *
 * @author : Manik-Jain
 */
//DO NOT EDIT THIS FILE
export default class FlureeSchema {
  public readonly modelSchema: CanonicalSchema;
  public readonly dao: FlureeService;
  public readonly fileUtil: FileUtil;

  private config: ModuleConfiguration;
  private toProcessCollections: string[];
  private collections: string[];
  private processedCollections: string[];
  private identifiers: any[] = [];
  public toInsertData: any = {};
  private pendingTransactions: any = {};
  private collectionObject = {};
  private collectionDefinitions: any[] = [];
  private modifiers: any[] = [];

  constructor(config: ModuleConfiguration) {
    this.modelSchema = canonicalSchemaLoader(`${process.cwd()}/../../../dist`);
    console.log(`Workspace Root: ${workspaceRoot}`);
    console.log(`Schema: ${JSON.stringify(this.modelSchema)}`);
    this.config = config;
    this.dao = new FlureeService();
    this.fileUtil = new FileUtil();
    this.toProcessCollections = [];
    this.collections = [];
    this.processedCollections = [];
    this.modifiers = [];
  }

  /**
   * recursively groups the indepedent and dependent collections
   *
   * @returns
   */
  sequence() {
    const referencedCollections: any[] = [];
    const independentCollections: any[] = [];

    this.modelSchema.definitions.forEach((def: Definition) => {
      const map = new Map();
      const predicateMap = new Map();

      def.props.forEach((prop) => {
        // const predicateValue =
        //   this.modelSchema[collection][PROPERTIES][predicate];
        if (
          prop.defType === DefinitionType.Entity ||
          prop.defType === DefinitionType.EntityArray
        ) {
          predicateMap.set(prop.name, prop.type);
        }
      });

      if (predicateMap.size === 0) {
        independentCollections.push(def.name);
      } else {
        map.set(def.name, predicateMap);
        referencedCollections.push(map);
      }
    });

    const map = new Map();

    referencedCollections.reduce((acc, val, index) => {
      map.set(index, val.get(val.keys().next().value).size);
      acc.push(val.get(val.keys().next().value).size);
      return acc;
    }, []);

    const sortedReferenced: any[] = [];
    Array.from(map.values())
      .sort((a, b) => a - b)
      .forEach((entry) => {
        const key = this.getKey(map, entry)[0];
        sortedReferenced.push(referencedCollections[key]);
        map.delete(key);
      });

    this.toProcessCollections = independentCollections;
    const keyValue = {};

    sortedReferenced.forEach((entry) => {
      for (const [key, value] of entry.entries()) {
        const children: string[] = [];
        for (const [childKey, childValue] of value.entries()) {
          children.push(childValue);
        }
        keyValue[key] = children;
      }
    });

    const associative: string[] = [];

    Object.keys(keyValue).forEach((key) => {
      const dependencies: string[] = keyValue[key];
      dependencies.forEach((dependency) => {
        if (!Object.keys(keyValue).includes(dependency)) {
          this.toProcessCollections.push(dependency);
          if (dependencies.length === 1) {
            this.toProcessCollections.push(key);
          }
        } else {
          associative.push(dependency);
          associative.push(key);
        }
      });
    });

    const sequence = {
      independentCollections: Array.from(new Set(this.toProcessCollections)),
      sortedReferenced: Array.from(new Set(associative)),
    };

    //this.fileUtil.write(path.resolve(__dirname + '/sequence.json'), sequence)

    return sequence;
  }

  getKey(map, searchValue) {
    return [...map.entries()]
      .filter(({ 1: v }) => v === searchValue)
      .map(([k]) => k);
  }

  /**
   * Connects to the fluree instance in order to check the existing collections, if any
   * @returns
   */
  async getCollections(): Promise<string[]> {
    const query: FlureeQuery = {
      select: [Predicates.NAME],
      from: FlureeCollection.COLLECTION,
    };

    const response = await this.dao.query(
      this.config.fluree.ledgerUrl,
      `${this.config.fluree.network}/${this.config.fluree.db}`,
      query
    );

    return response.reduce((acc, entry) => {
      if (!entry.name.startsWith(UNDERSCORE)) {
        acc.push(entry.name);
      }
      return acc;
    }, []);
  }

  async getPredicates(collection: string): Promise<string[]> {
    const response = await this.dao.query(
      this.config.fluree.ledgerUrl,
      `${this.config.fluree.network}/${this.config.fluree.db}`,
      predicates(collection)
    );
    return response.reduce((acc, entry) => {
      acc.push(entry.substring(entry.indexOf('/') + 1, entry.length));
      return acc;
    }, []);
  }

  async init(dump: boolean) {
    try {
      // create database if it doesn't exist
      const dbs: string[] = await this.dao.listDBs(
        this.config.fluree.ledgerUrl
      );
      if (
        !dbs.find(
          (db: string) =>
            db === `${this.config.fluree.network}/${this.config.fluree.db}`
        )
      ) {
        await this.dao.createDB(
          this.config.fluree.ledgerUrl,
          `${this.config.fluree.network}/${this.config.fluree.db}`
        );
        // pausing for 10 sec to let DB initialize
        // there doesn't seem to be a clean way for pinging the status
        // but if we find one later on, we may want to change that
        await sleep(10000);
      } else {
        console.log(`Database ${this.config.fluree.db} already exists`);
      }

      this.collections = await this.getCollections();

      const entities = this.modelSchema.definitions.map(
        (def: Definition) => def.name
      );

      for await (const entity of entities) {
        //Handle changes when new collections are added to schema
        if (!this.collections.includes(entity)) {
          console.log(`Preparing collection : ${entity.toUpperCase()}`);
          this.collectionObject[entity.toLocaleUpperCase()] = entity;
          const collection = this.generateCollection(entity);
          this.collectionDefinitions.push(collection);
          this.collectionDefinitions = _.flattenDeep(
            this.collectionDefinitions
          );
        }

        //handle case of any new predicate addition/removals
        else {
          console.log(
            `Checking any schema changes with collection : ${entity.toUpperCase()}`
          );
          const dbPredicates: string[] = await this.getPredicates(entity);
          const modifiers = this.resolve(entity, dbPredicates);

          if (isArray(modifiers)) {
            console.log(
              `Found schema changes for collection : ${entity.toUpperCase()}`
            );
            this.modifiers.push(modifiers);
            this.modifiers = _.flattenDeep(this.modifiers);
            console.log(`Updated modifier : ${this.modifiers.toString()}`);
          } else {
            console.log(
              `Found NO schema changes for collection : ${entity.toUpperCase()}. Proceeding with any further collection`
            );
          }
        }
      }

      if (this.collectionDefinitions.length > 0 && dump) {
        await this.dao.transact(
          this.config.fluree.ledgerUrl,
          `${this.config.fluree.network}/${this.config.fluree.db}`,
          this.collectionDefinitions
        );
      }

      if (this.modifiers.length > 0 && dump) {
        await this.dao.transact(
          this.config.fluree.ledgerUrl,
          `${this.config.fluree.network}/${this.config.fluree.db}`,
          this.modifiers
        );
      }

      console.log('DB synchronised with schema...');
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  async initialize(dump: boolean) {
    const collections = this.sequence();
    collections.independentCollections.forEach(async (collection) => {
      this.process(collection, false);
    });
    collections.sortedReferenced.forEach(async (entity) =>
      this.process(entity, false)
    );

    if (Object.keys(this.pendingTransactions).length > 0) {
      Object.keys(this.pendingTransactions).forEach((key) => {
        const pendingArray = this.pendingTransactions[key];
        this.toInsertData[key].forEach((entry) => {
          pendingArray.forEach((pendingKey) => {
            Object.keys(pendingKey).forEach((pKey) => {
              entry[pKey] =
                this.toInsertData[pendingKey[pKey]][0][Predicates._ID];
            });
          });
        });
      });
    }

    let data: any[] = [];
    Object.keys(this.toInsertData).forEach(async (key) => {
      data.push(this.toInsertData[key]);
      data = _.flatten(data);
    });

    if (dump) {
      //(path.resolve(__dirname + '/data.json'), data);
      await this.dao.transact(
        this.config.fluree.ledgerUrl,
        `${this.config.fluree.network}/${this.config.fluree.db}`,
        data
      );
    }

    console.log('Insertion complete...');
  }

  private process(collection: string, dump?: boolean) {
    if (this.processedCollections.includes(collection)) {
      console.log(
        `${collection} was already processed, and hence skipping re-init`
      );
      return;
    }

    console.log(`Processing ${collection}`);
    const transactions: any[] = [];
    const transaction = this.parse(collection);
    console.log(`Transaction: ${JSON.stringify(transaction)}`);
    if (transaction) {
      transactions.push(transaction);
      this.toInsertData[collection] = transactions;
      this.processedCollections.push(collection);
      this.identifiers[collection] =
        this.identifiers[collection] !== undefined &&
        this.identifiers[collection].size !== 0
          ? this.identifiers[collection].push(transaction[IDENTIFIER])
          : [transaction[IDENTIFIER]];
      console.log(`Finished Processing ${collection}`);
    }
  }

  public extractValue(type: string, prop: Partial<Property>) {
    if (type === STRING) {
      if (prop.examples !== undefined) {
        const value =
          prop.examples[
            Math.floor(Math.random() * (prop.examples.length - 1 + 1) + 1)
          ];
        return value !== undefined ? value : prop.examples[0];
      } else if (prop.defType === DefinitionType.Enum) {
        // TODO: Enable enum support in test data generator
        //https://ikigai-technologies.atlassian.net/browse/LOG-100
      } else {
        return randomstring.generate({
          length: prop.maxLength,
          charset: ALPHABETIC,
        });
      }
    } else if (type === NUMBER || type === INTEGER) {
      if (
        prop.description !== undefined &&
        prop.description.includes(UNIX_TIME)
      ) {
        return Date.now() + ONE_DAY_MS * Math.floor(Math.random() * 100);
      } else {
        return Math.floor(Math.random() * (ONE_THOUSAND - 1 + 1) + 1);
      }
    }
  }

  public parse(entity: string) {
    let isPending = false;
    const schema = this.modelSchema.definitions.find(
      (def: Definition) => def.name === entity
    );
    const data = {};
    const pending: any[] = [];
    schema.props.forEach((prop: Property) => {
      if (prop.defType === DefinitionType.Scalar && prop.type === STRING) {
        data[prop.name] = this.extractValue(prop.type, prop);
      } else if (prop.defType === DefinitionType.EntityArray) {
        const childEntity = prop.type;
        const index = 5;
        if (Object.keys(this.toInsertData).includes(childEntity)) {
          data[prop.name] = [this.toInsertData[childEntity][0][Predicates._ID]];
        }
        if (index > 0) {
          const identifiers: any[] = [];
          for (let i = 0; i < index; i++) {
            const appendedChild = this.parse(childEntity);
            identifiers.push(appendedChild[Predicates._ID]);
            this.toInsertData[childEntity].push(appendedChild);
          }
          data[prop.name] = identifiers;
        }
      }
      //scalar array
      else if (prop.defType === DefinitionType.ScalarArray) {
        data[prop.name] = [
          randomstring.generate({
            length: prop.maxLength,
            charset: ALPHABETIC,
          }),
        ];
      } else if (
        prop.defType === DefinitionType.Scalar &&
        (prop.type === NUMBER || prop.type === INTEGER)
      ) {
        data[prop.name] = this.extractValue(prop.type, prop);
      } else if (
        prop.defType === DefinitionType.Scalar &&
        prop.type === BOOLEAN
      ) {
        data[prop.name] = false;
      } else if (
        prop.defType === DefinitionType.Entity ||
        prop.defType === DefinitionType.Enum
      ) {
        if (
          prop.defType === DefinitionType.Entity &&
          !Object.keys(this.toInsertData).includes(prop.type)
        ) {
          isPending = true;
          Array.isArray(pending)
            ? pending.push({ [prop.name]: prop.type })
            : [{ [prop.name]: prop.type }];
        } else if (
          prop.defType === DefinitionType.Entity &&
          Object.keys(this.toInsertData).includes(prop.type)
        ) {
          data[prop.name] = this.toInsertData[prop.type][0][Predicates._ID];
        } else if (prop.defType === DefinitionType.Enum) {
          //data[prop.name] = [0];
          // TODO: Enable enum support in test data generator
          //https://ikigai-technologies.atlassian.net/browse/LOG-100
        }
      }
    });
    data[Predicates._ID] = entity;

    data[IDENTIFIER] = sha3_256(JSON.stringify(data));
    data[Predicates._ID] = `${entity}$${data[IDENTIFIER]}`;

    if (schema.props.find((prop: Property) => prop.name === CREATED_AT)) {
      data[CREATED_AT] = Date.now();
    }

    if (isPending) {
      this.pendingTransactions[entity] = pending;
    }

    return data;
  }

  /**
   * Generate collection transaction string
   *
   * @returns Collection transact statement
   */
  generateCollection(entityName): any[] {
    console.log(
      '*'.repeat(25) + '\n' + entityName.toUpperCase() + '\n' + '*'.repeat(25)
    );

    const collection: any[] = [
      {
        _id: Predicates.COLLECTION,
        name: entityName,
      },
      //   {
      //     _id: Predicates.PREDICATE,
      //     name: `${entityName}`.concat('/').concat(Predicates.OWNER),
      //     doc: `The ${entityName}'s data owner`,
      //     type: COLLECTION_REF,
      //     restrictCollection: FlureeCollection.USER,
      //     index: true,
      //   },
      {
        _id: Predicates.PREDICATE,
        name: `${entityName}`.concat('/').concat(Predicates.IDENTIFIER),
        doc: `The ${entityName}'s identifier`,
        type: STRING,
        unique: true,
        index: true,
      },
    ];
    const entitySchema: Definition = this.modelSchema.definitions.find(
      (def: Definition) => def.name === entityName
    );
    const collectionPredicates = entitySchema.props
      .map((prop: Property) => prop.name)
      .reduce((acc, k: string) => {
        acc.push(this.preparePredicate(entityName, k, entitySchema));
        return acc;
      }, collection);
    return collectionPredicates;
  }

  resolve(entityName: string, dbPredicates: string[]): any[] {
    const entitySchema = this.modelSchema.definitions.find(
      (def: Definition) => def.name === entityName
    );
    const collectionPredicates = entitySchema.props.map(
      (prop: Property) => prop.name
    );
    const transaction: any[] = [];

    const toAddPRedicates = _.difference(collectionPredicates, dbPredicates);

    toAddPRedicates.forEach((predicate) => {
      transaction.push(
        this.preparePredicate(entityName, predicate, entitySchema)
      );
    });

    const toDeletePRedicates = _.difference(dbPredicates, collectionPredicates);
    toDeletePRedicates.forEach((predicate) => {
      if (predicate !== 'owner') {
        transaction.push(deprecatePredicate(entityName, predicate));
      }
    });

    return transaction;
  }

  preparePredicate(
    entityName: string,
    predicateName: string,
    entitySchema: Definition
  ) {
    const predicate: FlureePredicate = {
      _id: Predicates.PREDICATE,
      name: `${entityName}/${predicateName}`,
      doc: `${entityName}'s ${predicateName} field`,
      ...(predicateName === IDENTIFIER && {
        index: true,
        unique: true,
      }),
      type: STRING,
    };

    const prop: Partial<Property> = entitySchema.props.find(
      (prop: Partial<Property>) => prop.name === predicateName
    );
    if (prop.defType === DefinitionType.EntityArray) {
      predicate.type = COLLECTION_REF;
      predicate.restrictCollection = prop.type;
      predicate.multi = true;
    } else if (prop.defType === DefinitionType.ScalarArray) {
      predicate.type = prop.type;
      predicate.multi = true;
    } else if (
      //TODO: Make time as it's own type
      // https://ikigai-technologies.atlassian.net/browse/LOG-99
      prop.description !== undefined &&
      prop.description.includes(TIME)
    ) {
      predicate.type = INSTANT;
    } else {
      const type =
        prop.type === INTEGER || prop.type === NUMBER ? BIGINT : prop.type;
      predicate.type =
        prop.defType === DefinitionType.Entity ||
        prop.defType === DefinitionType.Enum
          ? COLLECTION_REF
          : type;
    }

    // TODO: add unique to canonical schema
    // https://ikigai-technologies.atlassian.net/browse/LOG-99
    predicate.unique = prop.isPK;
    predicate.fullText = false;

    // referenced collections
    if (prop.defType === DefinitionType.Entity || DefinitionType.EntityArray) {
      predicate.restrictCollection = prop.type;
    }

    predicate.index = true;

    return predicate;
  }
}
